export const STAGE_6_FINAL_VERIFICATION = `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STAGE 6: JSON 검증 엔진 - 사실관계 정밀 검증
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

실행 모드: 알고리즘 우선 | 배치 최적화 | 수학적 정밀성
임무: Stage 5 JSON 사실 검증 + 부정확 데이터 수정 + 검증된 JSON 출력

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

§1. 입력 인터페이스
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

interface Stage5입력 {
  ticker: string;           // 형식: /^KOSPI:\d{6}$/
  name: string;             // 한글 회사명
  close_price: number;      // 전일 종가 (정수 또는 실수)
  rationale: string;        // 파이프 구분 지표 문자열
  signals: {
    trend_score: number;      // 0-100 정수
    momentum_score: number;   // 0-100 정수
    volume_score: number;     // 0-100 정수
    volatility_score: number; // 0-100 정수
    pattern_score: number;    // 0-100 정수
    sentiment_score: number;  // 0-100 정수
    overall_score: number;    // 0-100 정수 (가중 평균)
  };
}

type Stage6입력타입 = Stage5입력[];  // 정확히 3개 종목

입력_검증_규칙
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

필수_조건:
  종목.length === 3
  각 종목.ticker는 /^KOSPI:\d{6}$/ 형식
  각 종목.close_price > 0
  각 종목.rationale !== ""

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

§2. 배치 검증 알고리즘
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

알고리즘 2.1: Rationale 지표 파싱
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력: 종목[] (3개)
출력: 파싱된종목[] (지표 분류 완료)

각 종목에 대해:
  지표배열 = 종목.rationale.split("|").map(s => s.trim())

  숫자지표 = []
  상태지표 = []

  지표배열의 각 지표에 대해:
    만약 /\d+/.test(지표):  // 숫자 포함 여부
      숫자지표.push(지표)
    아니면:
      상태지표.push(지표)

  종목.파싱된지표 = {
    숫자: 숫자지표,
    상태: 상태지표,
    원본: 지표배열
  }

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

알고리즘 2.2: 검증 대상 추출 및 분류
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력: 파싱된종목[]
출력: 검증대상맵[]

각 종목에 대해:
  검증대상 = []

  종목.파싱된지표.숫자의 각 지표에 대해:

    만약 /RSI[:\s]+(\d+\.?\d*)/i.test(지표):
      검증대상.push({
        유형: "RSI",
        원본지표: 지표,
        주장값: parseFloat(match[1]),
        허용오차: 3,
        추출패턴: /RSI[:\s]+(\d+\.?\d*)/i
      })

    또는 /거래량[^\d]*(\d+\.?\d*)%/i.test(지표):
      검증대상.push({
        유형: "거래량비율",
        원본지표: 지표,
        주장값: parseFloat(match[1]),
        허용오차: 10,
        추출패턴: /거래량[^\d]*(\d+\.?\d*)%/i
      })

    또는 /ADX[:\s]+(\d+\.?\d*)/i.test(지표):
      검증대상.push({
        유형: "ADX",
        원본지표: 지표,
        주장값: parseFloat(match[1]),
        허용오차: 3,
        추출패턴: /ADX[:\s]+(\d+\.?\d*)/i
      })

    또는 /ATR[:\s]+(\d+\.?\d*)/i.test(지표):
      검증대상.push({
        유형: "ATR",
        원본지표: 지표,
        주장값: parseFloat(match[1]),
        허용오차: 5,
        추출패턴: /ATR[:\s]+(\d+\.?\d*)/i
      })

    또는 /이평선거리[:\s]+(\d+\.?\d*)%/i.test(지표):
      검증대상.push({
        유형: "이평선거리",
        원본지표: 지표,
        주장값: parseFloat(match[1]),
        허용오차: 2,
        추출패턴: /이평선거리[:\s]+(\d+\.?\d*)%/i
      })

  종목.검증대상 = 검증대상

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

알고리즘 2.3: 배치 검색 실행 (Google Search Tool)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

도구_사양:
  도구명: GoogleSearchRetrieval
  API: grounding.google_search_retrieval
  동적_검색_임계값: dynamic_retrieval_config.dynamic_threshold
  최대결과수: 기본값 5

검색_최적화_전략:
  기존: 36개 개별 검색 (종목당 12개 × 3종목)
  최적화: 3-6개 배치 검색 (종목당 1-2개 × 3종목)
  감소율: 83-91%

배치_검색_알고리즘
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

각 종목에 대해:

  // 배치 1: 핵심 숫자 지표
  검색쿼리_1 = 쿼리생성({
    종목코드: 종목.ticker.replace("KOSPI:", ""),
    종목명: 종목.name,
    키워드: ["RSI", "ADX", "ATR", "현재가"],
    날짜: "2025-11-19",
    사이트필터: "finance.naver.com OR stockplus.com"
  })

  // 예시: "삼성전자 005930 RSI ADX ATR 현재가 2025-11-19 site:finance.naver.com OR site:stockplus.com"

  결과_1 = GoogleSearchRetrieval.search({
    query: 검색쿼리_1,
    max_results: 5,
    dynamic_threshold: 0.7
  })

  // 배치 2: 거래량 및 가격 데이터
  검색쿼리_2 = 쿼리생성({
    종목코드: 종목.ticker.replace("KOSPI:", ""),
    키워드: ["거래량", "평균거래량", "전일종가", "시가총액"],
    날짜: "2025-11-19"
  })

  결과_2 = GoogleSearchRetrieval.search({
    query: 검색쿼리_2,
    max_results: 5,
    dynamic_threshold: 0.7
  })

  // 배치 3: 이동평균 및 추세 지표
  만약 종목.검증대상에 ("SMA"|"EMA"|"이평선") 포함:
    검색쿼리_3 = 쿼리생성({
      종목코드: 종목.ticker.replace("KOSPI:", ""),
      키워드: ["SMA", "EMA", "이동평균선", "정배열", "골든크로스"],
      날짜: "2025-11-19"
    })

    결과_3 = GoogleSearchRetrieval.search({
      query: 검색쿼리_3,
      max_results: 5,
      dynamic_threshold: 0.7
    })

  // 배치 4: 오실레이터 (조건부)
  만약 종목.검증대상에 ("MACD"|"스토캐스틱"|"볼린저밴드") 포함:
    검색쿼리_4 = 쿼리생성({
      종목코드: 종목.ticker.replace("KOSPI:", ""),
      키워드: ["MACD", "스토캐스틱", "볼린저밴드"],
      날짜: "2025-11-19"
    })

    결과_4 = GoogleSearchRetrieval.search({
      query: 검색쿼리_4,
      max_results: 5,
      dynamic_threshold: 0.7
    })

  종목.검색결과원본 = [결과_1, 결과_2, 결과_3, 결과_4].filter(Boolean)
  종목.검색결과텍스트 = 종목.검색결과원본.flatMap(r =>
    r.map(item => item.title + " " + item.snippet)
  ).join("\n")

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

알고리즘 2.4: 실제 값 추출 (정밀 파싱)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력: 종목[] (검색결과텍스트 포함)
출력: 종목[] (실제값 맵 포함)

추출_패턴_정의
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

상수 추출패턴 = {
  RSI: {
    패턴: /RSI[:\s]+(\d+\.?\d*)/gi,
    변환: parseFloat,
    검증: (v) => v >= 0 && v <= 100
  },

  거래량비율: {
    패턴: /거래량[^\d]*(\d+\.?\d*)%/gi,
    변환: parseFloat,
    검증: (v) => v >= 0
  },

  ADX: {
    패턴: /ADX[:\s]+(\d+\.?\d*)/gi,
    변환: parseFloat,
    검증: (v) => v >= 0 && v <= 100
  },

  ATR: {
    패턴: /ATR[:\s]+(\d+\.?\d*)/gi,
    변환: parseFloat,
    검증: (v) => v >= 0
  },

  이평선거리: {
    패턴: /이평선거리[:\s]+(\d+\.?\d*)%/gi,
    변환: parseFloat,
    검증: (v) => true
  },

  종가: {
    패턴: /종가[:\s]+(\d{1,3}(,\d{3})*)/gi,
    변환: (s) => parseFloat(s.replace(/,/g, "")),
    검증: (v) => v > 0
  }
}

상수 상태패턴 = {
  SMA정배열: {
    패턴: /(완전정배열|정배열|부분정배열)/gi,
    값매핑: {
      "완전정배열": "완전정배열",
      "정배열": "완전정배열",
      "부분정배열": "부분정배열"
    }
  },

  MACD상태: {
    패턴: /MACD[^\n]*(골든크로스|양전환|매수|데드크로스|음전환|매도)/gi,
    값매핑: {
      "골든크로스": "양전환",
      "양전환": "양전환",
      "매수": "양전환",
      "데드크로스": "음전환",
      "음전환": "음전환",
      "매도": "음전환"
    }
  },

  EMA크로스: {
    패턴: /EMA[^\n]*(골든크로스|데드크로스)/gi,
    값매핑: {
      "골든크로스": "골든크로스",
      "데드크로스": "데드크로스"
    }
  }
}

추출_실행
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

각 종목에 대해:
  실제값 = {}

  // 숫자 지표 추출
  추출패턴의 각 [지표명, 사양]에 대해:
    매칭배열 = []
    패턴 = new RegExp(사양.패턴)

    매칭 = null
    while ((매칭 = 패턴.exec(종목.검색결과텍스트)) !== null):
      원시값 = 사양.변환(매칭[1])

      만약 사양.검증(원시값):
        매칭배열.push({
          값: 원시값,
          출처: 매칭.input.substring(Math.max(0, 매칭.index - 50), 매칭.index + 50)
        })

    // 우선순위: finance.naver.com > 최신 > 중앙값
    만약 매칭배열.length > 0:
      naver결과 = 매칭배열.filter(m => m.출처.includes("naver"))

      만약 naver결과.length > 0:
        실제값[지표명] = naver결과[0].값
      아니면:
        // 중앙값 사용
        정렬된값 = 매칭배열.map(m => m.값).sort((a,b) => a-b)
        실제값[지표명] = 정렬된값[Math.floor(정렬된값.length / 2)]

  // 상태 지표 추출
  상태패턴의 각 [지표명, 사양]에 대해:
    매칭 = 사양.패턴.exec(종목.검색결과텍스트)

    만약 매칭 !== null:
      원시상태 = 매칭[1]
      정규화상태 = 사양.값매핑[원시상태] || 원시상태
      실제값[지표명] = 정규화상태

  종목.실제값 = 실제값

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

알고리즘 2.5: 지표 검증 및 수정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력: 종목[] (실제값 포함)
출력: 종목[] (수정된 rationale + 수정로그)

구간_판정_함수
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

함수 RSI구간_판정(rsi: number): string {
  만약 rsi >= 70: return "과열권"
  또는 rsi >= 50: return "강세권"
  또는 rsi >= 30: return "중립권"
  아니면: return "약세권"
}

함수 ADX강도_판정(adx: number): string {
  만약 adx >= 40: return "매우강한추세"
  또는 adx >= 25: return "강한추세"
  또는 adx >= 20: return "추세형성"
  아니면: return "약한추세"
}

함수 거래량추세_판정(비율: number): string {
  만약 비율 >= 200: return "급증"
  또는 비율 >= 150: return "크게증가"
  또는 비율 >= 100: return "증가"
  또는 비율 >= 80: return "감소"
  아니면: return "급감"
}

검증_실행
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

각 종목에 대해:
  수정사항 = []
  검증된지표 = []

  // 숫자 지표 검증
  종목.파싱된지표.숫자의 각 지표에 대해:

    만약 /RSI/i.test(지표):
      매칭 = /RSI[:\s]+(\d+\.?\d*)/i.exec(지표)
      주장값 = parseFloat(매칭[1])
      실제값 = 종목.실제값["RSI"]

      만약 실제값 === undefined:
        수정사항.push({
          유형: "검증실패_삭제",
          원본: 지표,
          이유: "RSI 값 검색 결과 없음"
        })
        // 오류 복구: 검증 불가 시 원본 유지 (오류_3 전략)
        검증된지표.push(지표 + " [미검증]")
        계속

      오차 = Math.abs(실제값 - 주장값)

      만약 오차 <= 3:
        검증된지표.push(지표)
      아니면:
        구간 = RSI구간_판정(실제값)
        수정됨 = \`RSI \${실제값.toFixed(1)} \${구간}\`
        검증된지표.push(수정됨)
        수정사항.push({
          유형: "수정",
          원본: 지표,
          수정값: 수정됨,
          실제값: 실제값,
          주장값: 주장값,
          오차: 오차
        })

    또는 /거래량.*%/i.test(지표):
      매칭 = /거래량[^\d]*(\d+\.?\d*)%/i.exec(지표)
      주장값 = parseFloat(매칭[1])
      실제값 = 종목.실제값["거래량비율"]

      만약 실제값 === undefined:
        수정사항.push({
          유형: "검증실패_삭제",
          원본: 지표,
          이유: "거래량 비율 검색 결과 없음"
        })
        검증된지표.push(지표 + " [미검증]")
        계속

      오차 = Math.abs(실제값 - 주장값)

      만약 오차 <= 10:
        검증된지표.push(지표)
      아니면:
        추세 = 거래량추세_판정(실제값)
        수정됨 = \`거래량 \${실제값.toFixed(1)}% \${추세}\`
        검증된지표.push(수정됨)
        수정사항.push({
          유형: "수정",
          원본: 지표,
          수정값: 수정됨,
          실제값: 실제값,
          주장값: 주장값
        })

    또는 /ADX/i.test(지표):
      매칭 = /ADX[:\s]+(\d+\.?\d*)/i.exec(지표)
      주장값 = parseFloat(매칭[1])
      실제값 = 종목.실제값["ADX"]

      만약 실제값 === undefined:
        검증된지표.push(지표 + " [미검증]")
        계속

      오차 = Math.abs(실제값 - 주장값)

      만약 오차 <= 3:
        검증된지표.push(지표)
      아니면:
        강도 = ADX강도_판정(실제값)
        수정됨 = \`ADX \${실제값.toFixed(1)} \${강도}\`
        검증된지표.push(수정됨)
        수정사항.push({
          유형: "수정",
          원본: 지표,
          수정값: 수정됨,
          실제값: 실제값,
          주장값: 주장값
        })

    아니면:
      // 기타 숫자 지표는 원본 유지
      검증된지표.push(지표)

  // 상태 지표 검증
  종목.파싱된지표.상태의 각 지표에 대해:

    만약 /SMA.*정배열/i.test(지표):
      실제상태 = 종목.실제값["SMA정배열"]

      만약 실제상태 === "완전정배열" 그리고 지표.includes("완전정배열"):
        검증된지표.push(지표)
      또는 실제상태 === "부분정배열":
        수정됨 = "SMA 부분정배열"
        검증된지표.push(수정됨)
        수정사항.push({
          유형: "수정",
          원본: 지표,
          수정값: 수정됨,
          실제값: 실제상태
        })
      또는 실제상태 === undefined:
        검증된지표.push(지표 + " [미검증]")
      아니면:
        수정사항.push({
          유형: "검증실패_삭제",
          원본: 지표,
          이유: "정배열 상태 불일치"
        })

    또는 /MACD/i.test(지표):
      실제상태 = 종목.실제값["MACD상태"]

      만약 실제상태 === "양전환" 그리고 /(양전환|골든크로스|매수)/i.test(지표):
        검증된지표.push(지표)
      또는 실제상태 === "음전환" 그리고 /(음전환|데드크로스|매도)/i.test(지표):
        검증된지표.push(지표)
      또는 실제상태 === undefined:
        검증된지표.push(지표 + " [미검증]")
      아니면:
        수정사항.push({
          유형: "검증실패_삭제",
          원본: 지표,
          이유: "MACD 상태 불일치"
        })

    아니면:
      // 검증 불가능한 상태 지표는 원본 유지
      검증된지표.push(지표)

  // 최소 10개 지표 요구사항 (오류_4 복구)
  만약 검증된지표.length < 10:
    부족개수 = 10 - 검증된지표.length

    // 검색 결과에서 검증된 추가 지표 추출
    추가지표후보 = []

    만약 종목.실제값["종가"] !== undefined:
      추가지표후보.push(\`현재가 \${종목.실제값["종가"]}원\`)

    만약 종목.실제값["ATR"] !== undefined:
      추가지표후보.push(\`ATR \${종목.실제값["ATR"].toFixed(1)}\`)

    만약 종목.실제값["이평선거리"] !== undefined:
      추가지표후보.push(\`20일선대비 \${종목.실제값["이평선거리"].toFixed(1)}%\`)

    // 최대 부족개수만큼 추가
    추가지표 = 추가지표후보.slice(0, 부족개수)
    검증된지표.push(...추가지표)

    만약 추가지표.length > 0:
      수정사항.push({
        유형: "추가",
        추가된지표: 추가지표,
        이유: "최소 10개 지표 요구사항"
      })

  종목.검증된지표 = 검증된지표
  종목.수정된rationale = 검증된지표.join(" | ")
  종목.수정로그 = 수정사항

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

§3. 점수 재계산 엔진
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

알고리즘 3.1: Signals 점수 조정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력: 종목[] (수정로그 포함)
출력: 종목[] (조정된 signals)

상수 가중치 = {
  trend_score: 0.20,
  momentum_score: 0.20,
  volume_score: 0.15,
  volatility_score: 0.10,
  pattern_score: 0.20,
  sentiment_score: 0.15
}

상수 영향도매트릭스 = {
  // 수정 패턴 → 점수 조정값

  // Trend Score 영향
  "SMA_완전정배열→부분정배열": {trend_score: -10},
  "SMA_완전정배열→삭제": {trend_score: -15},
  "EMA_골든크로스→삭제": {trend_score: -12},
  "ADX_강한추세→추세형성": {trend_score: -5},
  "ADX_강한추세→약한추세": {trend_score: -10},

  // Momentum Score 영향
  "RSI_강세권→과열권": {momentum_score: -8},
  "RSI_강세권→중립권": {momentum_score: -12},
  "RSI_강세권→약세권": {momentum_score: -20},
  "MACD_양전환→삭제": {momentum_score: -18},
  "스토캐스틱_상승→삭제": {momentum_score: -10},

  // Volume Score 영향
  "거래량_급증→증가": {volume_score: -10},
  "거래량_크게증가→증가": {volume_score: -5},
  "거래량_증가→감소": {volume_score: -25},
  "거래량_증가→급감": {volume_score: -40},
  "OBV_상승→삭제": {volume_score: -8},

  // Volatility Score 영향
  "ATR_적정→과도": {volatility_score: -10},
  "볼린저밴드_중상단→하단": {volatility_score: -12},

  // Pattern Score 영향
  "차트패턴_삭제": {pattern_score: -8},

  // Sentiment Score 영향
  "외국인매수→삭제": {sentiment_score: -10},
  "기관매수→삭제": {sentiment_score: -10}
}

함수 수정사항_패턴매핑(수정사항: object): string {
  만약 수정사항.유형 === "수정":
    원본 = 수정사항.원본
    수정값 = 수정사항.수정값

    // RSI 패턴 매핑
    만약 /RSI/i.test(원본):
      원본구간 = /(강세권|과열권|중립권|약세권)/.exec(원본)?.[1]
      수정구간 = /(강세권|과열권|중립권|약세권)/.exec(수정값)?.[1]

      만약 원본구간 그리고 수정구간 그리고 원본구간 !== 수정구간:
        return \`RSI_\${원본구간}→\${수정구간}\`

    // 거래량 패턴 매핑
    또는 /거래량/i.test(원본):
      원본추세 = /(급증|크게증가|증가|감소|급감)/.exec(원본)?.[1]
      수정추세 = /(급증|크게증가|증가|감소|급감)/.exec(수정값)?.[1]

      만약 원본추세 그리고 수정추세 그리고 원본추세 !== 수정추세:
        return \`거래량_\${원본추세}→\${수정추세}\`

    // SMA 패턴 매핑
    또는 /SMA.*정배열/i.test(원본):
      만약 원본.includes("완전정배열") 그리고 수정값.includes("부분정배열"):
        return "SMA_완전정배열→부분정배열"

    // MACD 패턴 매핑
    또는 /MACD/i.test(원본):
      만약 원본.includes("양전환") 그리고 수정사항.유형 === "검증실패_삭제":
        return "MACD_양전환→삭제"

  또는 수정사항.유형 === "검증실패_삭제":
    만약 /EMA.*골든크로스/.test(수정사항.원본):
      return "EMA_골든크로스→삭제"
    또는 /SMA.*완전정배열/.test(수정사항.원본):
      return "SMA_완전정배열→삭제"
    또는 /OBV.*상승/.test(수정사항.원본):
      return "OBV_상승→삭제"

  return null
}

점수_재계산_실행
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

각 종목에 대해:
  조정값 = {
    trend_score: 0,
    momentum_score: 0,
    volume_score: 0,
    volatility_score: 0,
    pattern_score: 0,
    sentiment_score: 0
  }

  종목.수정로그의 각 수정사항에 대해:
    패턴 = 수정사항_패턴매핑(수정사항)

    만약 패턴 그리고 영향도매트릭스[패턴]:
      영향도 = 영향도매트릭스[패턴]

      영향도의 각 [점수키, 조정값]에 대해:
        조정값[점수키] += 조정값

  // 원본 점수에 조정값 적용
  새signals = {}

  점수키배열 = ["trend_score", "momentum_score", "volume_score",
                "volatility_score", "pattern_score", "sentiment_score"]

  점수키배열의 각 키에 대해:
    원본점수 = 종목.signals[키]
    조정 = 조정값[키]

    // 범위 제한: 0-100
    새점수 = Math.max(0, Math.min(100, 원본점수 + 조정))
    새signals[키] = Math.round(새점수)

  // overall_score 재계산 (가중 평균)
  overall = 0
  overall += 새signals.trend_score * 가중치.trend_score
  overall += 새signals.momentum_score * 가중치.momentum_score
  overall += 새signals.volume_score * 가중치.volume_score
  overall += 새signals.volatility_score * 가중치.volatility_score
  overall += 새signals.pattern_score * 가중치.pattern_score
  overall += 새signals.sentiment_score * 가중치.sentiment_score

  새signals.overall_score = Math.round(overall)

  종목.조정된signals = 새signals

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

§4. 통합 오류 복구 시스템
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

알고리즘 4.1: 오류 분류 및 복구 전략
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

오류_1: 검색결과_없음
  트리거: GoogleSearchRetrieval 반환값이 빈 배열 또는 null

  복구_절차:
    1단계: 단순화된 쿼리로 재시도
      검색쿼리 = 종목명 + " " + 종목코드 + " 기술적지표"
      재시도 = GoogleSearchRetrieval.search(검색쿼리)

    2단계: 대체 사이트로 재시도
      검색쿼리 += " site:investing.com OR site:stockplus.com"
      재시도 = GoogleSearchRetrieval.search(검색쿼리)

    3단계: 여전히 실패 시 원본 유지
      검증된지표 = 종목.파싱된지표.원본.map(지표 => 지표 + " [검색실패_미검증]")
      로그.push({
        오류: "검색결과_없음",
        복구: "원본_유지",
        상태: "경고"
      })

오류_2: 모호한_추출
  트리거: 동일 지표에 대해 3개 이상의 서로 다른 값 추출

  복구_절차:
    1단계: 출처 우선순위 적용
      우선순위 = ["finance.naver.com", "stockplus.com", "investing.com"]

      우선순위의 각 사이트에 대해:
        만약 매칭배열에 사이트 포함:
          선택값 = 해당_사이트의_첫번째_값
          break

    2단계: 최신 타임스탬프 사용
      만약 검색결과에 날짜정보 포함:
        선택값 = 가장_최신_날짜의_값

    3단계: 중앙값 사용
      정렬된값 = 매칭배열.map(m => m.값).sort((a,b) => a-b)
      선택값 = 정렬된값[Math.floor(정렬된값.length / 2)]

      로그.push({
        오류: "모호한_추출",
        복구: "중앙값_사용",
        값배열: 매칭배열.map(m => m.값),
        선택값: 선택값
      })

오류_3: 지표값_누락
  트리거: rationale에 지표 존재하나 검색 결과에서 값 추출 실패

  복구_절차:
    1단계: 지표 유형 분류
      만약 /\d+/.test(지표):
        유형 = "숫자기반"
      아니면:
        유형 = "상태기반"

    2단계: 유형별 처리
      만약 유형 === "숫자기반":
        // 검증 불가능한 숫자는 [미검증] 플래그 추가
        검증된지표.push(지표 + " [미검증]")
        로그.push({
          오류: "지표값_누락",
          복구: "미검증_플래그_추가",
          지표: 지표
        })

      또는 유형 === "상태기반":
        // 상태 지표는 검증 실패 시에도 유지 (보수적 접근)
        검증된지표.push(지표 + " [미검증]")
        로그.push({
          오류: "지표값_누락",
          복구: "상태지표_원본유지",
          지표: 지표
        })

오류_4: 검증지표_부족
  트리거: 검증 후 검증된지표.length < 10

  복구_절차:
    1단계: 검색 결과에서 추가 지표 추출
      부족개수 = 10 - 검증된지표.length

      추가지표우선순위 = [
        "현재가",
        "ATR",
        "20일선대비거리",
        "60일선대비거리",
        "거래대금",
        "시가총액",
        "52주최고가대비",
        "52주최저가대비"
      ]

      추가지표 = []

      추가지표우선순위의 각 지표명에 대해:
        만약 종목.실제값[지표명] !== undefined:
          추가지표.push(지표명_포맷팅(지표명, 종목.실제값[지표명]))

          만약 추가지표.length >= 부족개수:
            break

      검증된지표.push(...추가지표)

      로그.push({
        오류: "검증지표_부족",
        복구: "추가지표_추출",
        추가개수: 추가지표.length,
        추가지표: 추가지표
      })

오류_5: 유효하지않은_JSON구조
  트리거: 최종 출력 JSON이 스키마 검증 실패

  복구_절차:
    1단계: 스키마 위반 필드 식별
      위반필드 = JSON스키마검증(종목)

    2단계: 필드별 복구
      만약 위반필드.includes("ticker"):
        종목.ticker = Stage5원본.ticker  // 원본 복원

      만약 위반필드.includes("close_price"):
        종목.close_price = Stage5원본.close_price

      만약 위반필드.includes("signals"):
        // signals 범위 검증
        신호키 = ["trend_score", "momentum_score", ...];

        신호키의 각 키에 대해:
          만약 종목.signals[키] < 0 또는 종목.signals[키] > 100:
            종목.signals[키] = Stage5원본.signals[키]

      로그.push({
        오류: "유효하지않은_JSON구조",
        복구: "Stage5_원본복원",
        위반필드: 위반필드
      })

대체_전략_실행
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

알고리즘 4.2: 전체 검증 실패 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

각 종목별_오류수 계산
실패_종목수 = 종목들.filter(종목 => 종목.수정로그.filter(l => l.유형 === "검증실패_삭제").length >= 5).length

만약 실패_종목수 >= 2:
  // 2개 이상 종목에서 5개 이상 지표 검증 실패

  로그.push({
    단계: "STAGE_6",
    상태: "중단",
    이유: "과다_검증_실패",
    실패종목수: 실패_종목수,
    조치: "Stage5_기준선_사용"
  })

  // Stage 5 출력으로 우아한 대체
  최종출력 = Stage5입력.map(종목 => ({
    ...종목,
    rationale: 종목.rationale + " [Stage6_검증중단]"
  }))

  return 최종출력

아니면:
  // 정상 처리: 검증된 종목 + 수정 로그 반환

  로그.push({
    단계: "STAGE_6",
    상태: "성공",
    수정종목수: 종목들.filter(종목 => 종목.수정로그.length > 0).length,
    총수정사항: 종목들.flatMap(종목 => 종목.수정로그).length
  })

  최종출력 = 종목들.map(종목 => ({
    ticker: 종목.ticker,
    name: 종목.name,
    close_price: 종목.close_price,
    rationale: 종목.수정된rationale,
    signals: 종목.조정된signals
  }))

  return 최종출력

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

§5. 출력 인터페이스 및 검증
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

interface Stage6출력 {
  ticker: string;           // /^KOSPI:\d{6}$/
  name: string;             // 한글 회사명
  close_price: number;      // 전일 종가 > 0
  rationale: string;        // 수정된 지표 문자열 (최소 10개)
  signals: {
    trend_score: number;      // 0-100 정수
    momentum_score: number;   // 0-100 정수
    volume_score: number;     // 0-100 정수
    volatility_score: number; // 0-100 정수
    pattern_score: number;    // 0-100 정수
    sentiment_score: number;  // 0-100 정수
    overall_score: number;    // 0-100 정수 (가중 평균)
  };
}

type Stage6출력타입 = Stage6출력[];  // 정확히 3개 종목

검증_체크리스트
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

함수 출력검증(종목들: Stage6출력타입): boolean {
  // 종목 수 검증
  만약 종목들.length !== 3:
    return false

  종목들의 각 종목에 대해:
    // ticker 형식 검증
    만약 !/^KOSPI:\d{6}$/.test(종목.ticker):
      return false

    // close_price 검증
    만약 종목.close_price <= 0 또는 !isFinite(종목.close_price):
      return false

    // rationale 검증
    지표개수 = 종목.rationale.split("|").filter(s => s.trim()).length

    만약 지표개수 < 10:
      return false

    // signals 범위 검증
    신호키 = ["trend_score", "momentum_score", "volume_score",
              "volatility_score", "pattern_score", "sentiment_score",
              "overall_score"]

    신호키의 각 키에 대해:
      값 = 종목.signals[키]

      만약 값 < 0 또는 값 > 100 또는 !Number.isInteger(값):
        return false

    // overall_score 가중평균 검증
    계산된overall = Math.round(
      종목.signals.trend_score * 0.20 +
      종목.signals.momentum_score * 0.20 +
      종목.signals.volume_score * 0.15 +
      종목.signals.volatility_score * 0.10 +
      종목.signals.pattern_score * 0.20 +
      종목.signals.sentiment_score * 0.15
    )

    만약 Math.abs(계산된overall - 종목.signals.overall_score) > 1:
      return false

  return true
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

§6. 실행 흐름 사양
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

절차 STAGE_6_실행(Stage5입력: Stage5입력[]): Stage6출력[] {

  // ═══════════════════════════════════════════════════════
  // 단계 1: 입력 검증 및 파싱
  // ═══════════════════════════════════════════════════════

  만약 Stage5입력.length !== 3:
    throw Error("입력 종목 수 오류: 3개 필요, " + Stage5입력.length + "개 수신")

  종목들 = Stage5입력.map(종목 => ({
    ...종목,
    파싱된지표: null,
    검증대상: null,
    검색결과원본: null,
    검색결과텍스트: null,
    실제값: null,
    검증된지표: null,
    수정된rationale: null,
    수정로그: [],
    조정된signals: null
  }))

  // ═══════════════════════════════════════════════════════
  // 단계 2: 배치 검증 실행 (§2)
  // ═══════════════════════════════════════════════════════

  // 2.1: 지표 파싱
  알고리즘2.1_실행(종목들)

  // 2.2: 검증 대상 추출
  알고리즘2.2_실행(종목들)

  // 2.3: 배치 검색 실행
  try {
    알고리즘2.3_실행(종목들)
  } catch (검색오류) {
    // 오류_1: 검색결과_없음 복구
    알고리즘4.1_오류1_복구(종목들, 검색오류)
  }

  // 2.4: 실제 값 추출
  try {
    알고리즘2.4_실행(종목들)
  } catch (추출오류) {
    // 오류_2: 모호한_추출 복구
    알고리즘4.1_오류2_복구(종목들, 추출오류)
  }

  // 2.5: 지표 검증 및 수정
  알고리즘2.5_실행(종목들)

  // ═══════════════════════════════════════════════════════
  // 단계 3: 점수 재계산 (§3)
  // ═══════════════════════════════════════════════════════

  알고리즘3.1_실행(종목들)

  // ═══════════════════════════════════════════════════════
  // 단계 4: 통합 오류 복구 (§4)
  // ═══════════════════════════════════════════════════════

  // 4.1: 개별 오류 처리 (이미 단계 2에서 처리됨)

  // 4.2: 전체 검증 실패 처리
  최종출력 = 알고리즘4.2_실행(종목들, Stage5입력)

  // ═══════════════════════════════════════════════════════
  // 단계 5: 출력 검증 (§5)
  // ═══════════════════════════════════════════════════════

  검증통과 = 출력검증(최종출력)

  만약 !검증통과:
    // 오류_5: 유효하지않은_JSON구조 복구
    최종출력 = 알고리즘4.1_오류5_복구(최종출력, Stage5입력)

    // 재검증
    검증통과 = 출력검증(최종출력)

    만약 !검증통과:
      throw Error("Stage 6 출력 검증 실패: 복구 불가능")

  // ═══════════════════════════════════════════════════════
  // 단계 6: 최종 JSON 반환
  // ═══════════════════════════════════════════════════════

  return 최종출력
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

§7. 성능 및 품질 목표
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

효율성_목표
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

검색_최적화:
  기존: 36개 개별 검색 (종목당 12개 × 3종목)
  최적화: 3-6개 배치 검색 (종목당 1-2개 × 3종목)
  감소율: 83-91% API 호출 감소

실행_시간:
  기존_예상: 15-20초 (순차 검색)
  최적화_목표: 4-6초 (배치 병렬 검색)
  개선율: 60-75% 속도 향상

정확도_목표
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

지표_검증_정확도: ≥95%
  숫자지표_허용오차:
    RSI: ±3
    거래량: ±10%
    ADX: ±3
    ATR: ±5
    이평선거리: ±2%

  상태지표_일치도: 완전일치 또는 하위호환

점수_재계산_정확도: ≥99%
  overall_score 오차범위: ±1
  가중평균 공식 준수

오류_복구_성공률: ≥95%
  복구_불가능_오류율: <5%
  우아한_대체_실행률: 100%

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

§8. 실행 지시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

이 사양서의 알고리즘을 사용하여 STAGE 6 실행:

실행_순서:
  1. Stage 5 JSON 파싱 (§1)
  2. 배치 검증 실행 (§2.1-2.5)
  3. 배치 검색 3-6개 실행 (§2.3)
  4. 실제 값 정밀 추출 (§2.4)
  5. 지표 검증 및 수정 (§2.5)
  6. 점수 재계산 (§3.1)
  7. 통합 오류 복구 (§4.1-4.2)
  8. 출력 검증 (§5)
  9. 최종 JSON 반환

핵심_규칙:
  - GoogleSearchRetrieval API만 사용 (배치 최적화)
  - 검증 불가 시 [미검증] 플래그 추가 (보수적 접근)
  - 종목당 최소 10개 rationale 지표 필수
  - overall_score = 정확한 가중평균 공식
  - 2개 이상 종목 검증 실패 시 Stage 5 출력 사용
  - 모든 오류는 복구 시도 후 로그 기록

STAGE 6 실행 시작.`;